---
title: Python 随记
date: 2022-08-21 23:53:25
permalink: /pages/b98720/
---
## 1. sort() 与 sorted() 的区别

 ### 描述

>   我们需要对 List 进行排序，Python 提供了两个方法对给定的 List 进行排序 ：
>     方法1.用对 List 的成员函数 sort 进行排序
>     方法2.用内置函数 sorted 进行排序

### 区别

- sort() 是在原位重新排列列表，而 sorted() 是产生一个新的列表。
- sort() 是应用在 list 上的方法，sorted() 可以对所有可迭代的对象进行排序操作。

### 代码实例

```python
>>> a=[1,2,5,3,9,4,6,8,7,0,12]
>>> a.sort()
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12]

>>> a=[1,2,5,3,9,4,6,8,7,0,12]
>>> sorted(a)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12]
>>> a
[1, 2, 5, 3, 9, 4, 6, 8, 7, 0, 12]

区别：
对于一个无序的列表a，调用a.sort()，对a进行排序后返回a，sort()函数修改待排序的列表内容。
而对于同样一个无序的列表a，调用sorted(a)，对a进行排序后返回一个新的列表，而对a不产生影响。
```

## 2. 列表去重的方法

常用方法：用集合 set() 去重

> 将 list 转化为 set 再转化为 list ，利用 set 的自动去重功能，但不保证顺序。 

```python
old_list = [2, 3, 4, 5, 1, 2, 3]
new_list = list(set(old_list))
print(new_list) # 不保证顺序：[1, 2, 3, 4, 5]
```









# 刷题小记

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

- 迭代法（迭代需要三个指针，pre，cur，nxt，分别按顺序指向三个节点）

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                pre, cur = None, head
                while cur:
                    nxt = cur.next
                    cur.next = pre
                    pre = cur
                    cur = nxt
                return pre
        
        ```

    

- 递归法

    - 头递归

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                def helper(pre, cur):
                    if not cur:
                        return pre
                    tmp = cur.next
                    cur.next = pre
                    return helper(cur,tmp)
                return helper(None, head)
        
        ```

        

    - **尾递归**

    - > 递归求解本题理解上有一定的难度，主要需要搞清楚定义的递归函数F(n)的意义。
        >
        > - 无序列表本题中F(n)定义为：反转头为n的链表，并返回新的表头，也就是原链表的最后一个节点；
        > - 无序列表那么F(n.next)的含义为：反转头为n.next的链表，并返回新的表头
        >
        > <u>接下来要想清楚已知F(n.next)的条件下，如何得到F(n)。</u>
        >
        > <u>注意F(n）和F(n.next）的表头是一致的，所以直接返回就好。关键问题是将n.next指向n，即进行以下操作：</u>
        >
        > n.next.next = n
        >
        > n.next = None

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                if not head or not head.next:
                    return head
                new_head = self.reverseList(head.next)
                head.next.next = head
                head.next = None
                return new_head
        
        ```

        

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

- 滑动窗口（未掌握）

    - ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                res = left = right = 0
                tmp = []
                while right < len(s):
                    if s[right] in tmp:
                        tmp.pop(0)
                        left = left + 1
                    else:
                        tmp.append(s[right])
                        right = right + 1
                        res = max(res, len(tmp))
                return res
        
        ```

    - ```python
        ## 相对优化
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                res = 0
                tmp = []
                for i in s:
                    if i in tmp:
                        tmp = tmp[tmp.index(i) + 1:]
                    tmp.append(i)
                    res = max(res, len(tmp))
                return res
        
        ```



## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

- 做题时先给面试官讲一遍LRU和LinkedHashMap的八股，再自己使用双向链表实现就好，考虑自己写输入输出--自己创建链表+hashmap解决

    - ```python
        
        ```

        

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

- 堆排序（未掌握）
- 快速排序

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

- 排序加双指针（注意去除重复）--考虑所有情况即可

- ```python
    
    class Solution:
        def threeSum(self, nums: List[int]) -> List[List[int]]:
            n = len(nums)
            nums.sort()
            res = []
            for i in range(n):
                if nums[i] > 0:
                    return res
                if i > 0 and nums[i - 1] == nums[i]:
                    continue
                temp = -nums[i]
                left = i + 1
                right = n - 1
                while left < right:
                    if nums[left] + nums[right] == temp:
                        res.append([nums[i], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                        	left = left + 1
                        while left < right and nums[right] == nums[right - 1]:
                        	right = right - 1
                        left = left + 1
                        right = right - 1
                    elif nums[left] + nums[right] < temp:
                        left = left + 1
                    else:
                        right = right - 1
            return res
        
    ```
    



## [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

- 参考[排序算法](https://crush598.github.io/Hush-notes/pages/061c78/)

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

- 

































































