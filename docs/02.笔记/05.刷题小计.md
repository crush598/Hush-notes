

# 刷题小记

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

- 迭代法（迭代需要三个指针，pre，cur，nxt，分别按顺序指向三个节点）

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                pre, cur = None, head
                while cur:
                    nxt = cur.next
                    cur.next = pre
                    pre = cur
                    cur = nxt
                return pre
        
        ```

    

- 递归法

    - 头递归

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                def helper(pre, cur):
                    if not cur:
                        return pre
                    tmp = cur.next
                    cur.next = pre
                    return helper(cur,tmp)
                return helper(None, head)
        
        ```

        

    - **尾递归**

    - > 递归求解本题理解上有一定的难度，主要需要搞清楚定义的递归函数F(n)的意义。
        >
        > - 无序列表本题中F(n)定义为：反转头为n的链表，并返回新的表头，也就是原链表的最后一个节点；
        > - 无序列表那么F(n.next)的含义为：反转头为n.next的链表，并返回新的表头
        >
        > <u>接下来要想清楚已知F(n.next)的条件下，如何得到F(n)。</u>
        >
        > <u>注意F(n）和F(n.next）的表头是一致的，所以直接返回就好。关键问题是将n.next指向n，即进行以下操作：</u>
        >
        > n.next.next = n
        >
        > n.next = None

    - ```python
        class Solution:
            def reverseList(self, head: ListNode) -> ListNode:
                if not head or not head.next:
                    return head
                new_head = self.reverseList(head.next)
                head.next.next = head
                head.next = None
                return new_head
        
        ```

        

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

- 滑动窗口（未掌握）

    - ```python
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                res = left = right = 0
                tmp = []
                while right < len(s):
                    if s[right] in tmp:
                        tmp.pop(0)
                        left = left + 1
                    else:
                        tmp.append(s[right])
                        right = right + 1
                        res = max(res, len(tmp))
                return res
        
        ```

    - ```python
        ## 相对优化
        class Solution:
            def lengthOfLongestSubstring(self, s: str) -> int:
                res = 0
                tmp = []
                for i in s:
                    if i in tmp:
                        tmp = tmp[tmp.index(i) + 1:]
                    tmp.append(i)
                    res = max(res, len(tmp))
                return res
        
        ```



## [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/) ---- 需要多次练习

- 做题时先给面试官讲一遍LRU和LinkedHashMap的八股，再自己使用双向链表实现就好，考虑自己写输入输出--自己创建链表+hashmap解决

    - ```python
        class ListNode:
            def __init__(self, key = 0,val = 0):
                self.key = key
               	self.val = val
               	self.prev = None
                self.next = None
        class LRUCache:
            def __init__(self, capacity):
                self.capacity = capacity
                self.hashmap = {}
                self.head = ListNode()
                self.tail = ListNode()
                self.head.next = self.tail
                self.tail.prev = self.head
            def get(self, key):
                if key not in self.hashmap:
                    return -1
                node = self.hashmap[key]
                self.move_node_last(node)
                return node.val
            def move_node_last(self, node):
                self.remove_node(node)
                self.add_node_last(node)
            def remove_node(self, node):
                node.prev.next = node.next
                node.next.prev = node.prev
            def add_node_last(self, node):
                self.tail.prev.next = node
                node.prev = self.tail.prev
                node.next = self.tail
                self.tail.prev = node
            def put(self, key, value):
                if key in self.hashmap:
                    node = self.hashmap[key]
                    node.val = value
                    self.move_node_last(node)
                    return 
                if len(self.hashmap) == self.capacity:
                    del self.hashmap[self.head.next.key]
                    self.remove_node(self.head.next)
                node = ListNode(key, value)
                self.hashmap[key] = node
                self.add_node_last(node)
                    
        ```

        

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

- 堆排序（未掌握）
- 快速排序

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

- 排序加双指针（注意去除重复）--考虑所有情况即可

- ```python
      
    class Solution:
        def threeSum(self, nums: List[int]) -> List[List[int]]:
            n = len(nums)
            nums.sort()
            res = []
            for i in range(n):
                if nums[i] > 0:
                    return res
                if i > 0 and nums[i - 1] == nums[i]:
                    continue
                temp = -nums[i]
                left = i + 1
                right = n - 1
                while left < right:
                    if nums[left] + nums[right] == temp:
                        res.append([nums[i], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                        	left = left + 1
                        while left < right and nums[right] == nums[right - 1]:
                        	right = right - 1
                        left = left + 1
                        right = right - 1
                    elif nums[left] + nums[right] < temp:
                        left = left + 1
                    else:
                        right = right - 1
            return res
        
    ```



## [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

- 参考[排序算法](https://crush598.github.io/Hush-notes/pages/061c78/)

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

- 思路一：动态规划
- 思路二：**分治（应掌握）**

## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

- 哑结点 -- while 遍历两个元素

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

- hash 表的运用

## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

































